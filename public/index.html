<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Good Hall - Classroom</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- A-Frame (pinned to version compatible with extras v4.1.2) -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

    <!-- Physics system -->
    <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>

    <!-- aframe-extras v4.1.2 (has kinematic-body + movement-controls) -->
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v4.1.2/dist/aframe-extras.min.js"></script>

    <!-- Not sure why I have this -->
    <script src="index.js"></script>
    <!-- Components -->
    <script src="components/change-color-on-click.js"></script>
    <script src="components/toggle-target-on-click.js"></script>
    <!-- Sky -->
    <script src="skybox/skycomponent.js"></script>

    <style>
      html, body { margin:0; height:100%; }
      .hud {
        position:absolute;
        top:8px;
        left:10px;
        font:14px system-ui;
        color:#fff;
        background:rgba(0,0,0,.35);
        padding:6px 8px;
        border-radius:6px;
      }
    </style>

    <!-- ========== Movement / Look components ========== -->

    <!-- Only move with WASD -->
    <script>
    AFRAME.registerComponent('wasd-move-only', {
      schema: { speed: {type: 'number', default: 3} }, // meters per second
      init() {
        this.state = {w:false, a:false, s:false, d:false};
        this._vecF = new THREE.Vector3();
        this._vecR = new THREE.Vector3();

        this.onKeyDown = e => {
          if (e.code === 'KeyW') this.state.w = true;
          if (e.code === 'KeyA') this.state.a = true;
          if (e.code === 'KeyS') this.state.s = true;
          if (e.code === 'KeyD') this.state.d = true;
        };
        this.onKeyUp = e => {
          if (e.code === 'KeyW') this.state.w = false;
          if (e.code === 'KeyA') this.state.a = false;
          if (e.code === 'KeyS') this.state.s = false;
          if (e.code === 'KeyD') this.state.d = false;
        };
        window.addEventListener('keydown', this.onKeyDown);
        window.addEventListener('keyup', this.onKeyUp);
      },
      tick(time, dt) {
        const dsec = dt / 1000;
        if (!(this.state.w || this.state.a || this.state.s || this.state.d)) return;

        const obj = this.el.object3D;
        // get yaw object if present, so movement follows where we look
        const lc = this.el.components['look-controls'];
        const yawObj = lc && lc.yawObject ? lc.yawObject : obj;

        // forward on XZ plane
        this._vecF.set(0, 0, -1).applyQuaternion(yawObj.quaternion);
        this._vecF.y = 0;
        this._vecF.normalize();

        // right vector
        this._vecR.copy(this._vecF).cross(new THREE.Vector3(0, 1, 0)).normalize();

        let moveX = 0, moveZ = 0;
        if (this.state.w) { moveX += this._vecF.x; moveZ += this._vecF.z; }
        if (this.state.s) { moveX -= this._vecF.x; moveZ -= this._vecF.z; }
        if (this.state.d) { moveX += this._vecR.x; moveZ += this._vecR.z; }
        if (this.state.a) { moveX -= this._vecR.x; moveZ -= this._vecR.z; }

        const speed = this.data.speed * dsec;
        obj.position.x += moveX * speed;
        obj.position.z += moveZ * speed;
      },
      remove() {
        window.removeEventListener('keydown', this.onKeyDown);
        window.removeEventListener('keyup', this.onKeyUp);
      }
    });
    </script>

    <!-- look around smoothly with arrow keys -->
    <script>
    AFRAME.registerComponent('arrow-look', {
      schema: {
        yawSpeed:   {type: 'number', default: 90},   // deg per second
        pitchSpeed: {type: 'number', default: 75},   // deg per second
        clamp:      {type: 'number', default: 85}    // deg up:down
      },
      init() {
        this.state = { left:false, right:false, up:false, down:false };
        this.onKeyDown = e => {
          if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();
          if (e.code === 'ArrowLeft')  this.state.left  = true;
          if (e.code === 'ArrowRight') this.state.right = true;
          if (e.code === 'ArrowUp')    this.state.up    = true;
          if (e.code === 'ArrowDown')  this.state.down  = true;
        };
        this.onKeyUp = e => {
          if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();
          if (e.code === 'ArrowLeft')  this.state.left  = false;
          if (e.code === 'ArrowRight') this.state.right = false;
          if (e.code === 'ArrowUp')    this.state.up    = false;
          if (e.code === 'ArrowDown')  this.state.down  = false;
        };
        window.addEventListener('keydown', this.onKeyDown, {passive:false});
        window.addEventListener('keyup',   this.onKeyUp,   {passive:false});
      },
      tick(time, dt) {
        const dsec = dt / 1000;
        const deg2rad = Math.PI / 180;

        // prefer look-controls if present
        const lc = this.el.components['look-controls'];
        if (lc && lc.pitchObject && lc.yawObject) {
          const yaw = lc.yawObject.rotation;
          const pitch = lc.pitchObject.rotation;

          // apply yaw, left negative, right positive
          if (this.state.left)  yaw.y += this.data.yawSpeed * dsec * deg2rad;
          if (this.state.right) yaw.y +=  -this.data.yawSpeed * dsec * deg2rad;

          // apply pitch, up negative, down positive
          if (this.state.up)    pitch.x += this.data.pitchSpeed * dsec * deg2rad;
          if (this.state.down)  pitch.x +=  -this.data.pitchSpeed * dsec * deg2rad;

          // clamp pitch
          const clampRad = this.data.clamp * deg2rad;
          pitch.x = Math.max(-clampRad, Math.min(clampRad, pitch.x));
        } else {
          // fallback, no look-controls present
          const rot = this.el.getAttribute('rotation');
          if (this.state.left)  rot.y -= this.data.yawSpeed * dsec;
          if (this.state.right) rot.y += this.data.yawSpeed * dsec;
          if (this.state.up)    rot.x -= this.data.pitchSpeed * dsec;
          if (this.state.down)  rot.x += this.data.pitchSpeed * dsec;
          rot.x = Math.max(-this.data.clamp, Math.min(this.data.clamp, rot.x));
          this.el.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);
        }
      },
      remove() {
        window.removeEventListener('keydown', this.onKeyDown);
        window.removeEventListener('keyup',   this.onKeyUp);
      }
    });
    </script>

    <!-- prevent arrow keys from moving camera, only change direction -->
    <script>
    AFRAME.registerComponent('block-arrow-move', {
      init() {
        this.onKeyDown = e => {
          if (e.code === 'ArrowLeft' || e.code === 'ArrowRight' ||
              e.code === 'ArrowUp'   || e.code === 'ArrowDown') {
            e.preventDefault();
            e.stopPropagation();
            if (e.stopImmediatePropagation) e.stopImmediatePropagation();
          }
        };
        // capture true, so we intercept before other handlers
        window.addEventListener('keydown', this.onKeyDown, {capture: true});
      },
      remove() {
        window.removeEventListener('keydown', this.onKeyDown, {capture: true});
      }
    });
    </script>

</head>
<body>

<a-scene
    renderer="colorManagement: true; physicallyCorrectLights: true"
    physics="gravity: -9.8; debug: false"
    skybox-box="path: ./skybox/; ext: .jpg; rotTop: 1.5708; rotBottom: -1.5708">

    <!-- CLICKABLE BOX -->
    <a-box class="clickable"
           position="0 1.5 -3"
           material="color: #4CC3D9"
           change-color-on-click>
    </a-box>
    <!-- END CLICKABLE BOX -->

    <!-- LIGHTS -->
    <a-entity light="type: ambient; intensity: 0.45"></a-entity>
    <a-entity light="type: directional; intensity: 1.0" position="2 6 2"></a-entity>

    <!-- ASSETS -->
    <a-assets>
        <img id="groundTexture" src="images/Grass_With_Many_Paths.png" alt="">
    </a-assets>

    <!-- PLAYER RIG -->
    <a-entity id="rig" position="0 0 6" block-arrow-move>
      <a-camera
        look-controls
        arrow-look="yawSpeed:120; pitchSpeed:90; clamp:80"
        wasd-move-only="speed:3">

        <!-- cursor is INSIDE the camera so we raycast from POV -->
        <a-entity
            cursor="fuse: false"
            raycaster="objects: .clickable">
        </a-entity>

      </a-camera>
    </a-entity>

    <!-- GROUND COLLIDER -->
    <a-plane id="ground" src="#groundTexture"
             rotation="-90 0 0"
             width="200"
             height="200"
             static-body="shape: box">
    </a-plane>

</a-scene>

</body>
</html>
